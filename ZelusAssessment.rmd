---
title: "Zelus Data Analysis Assessment"
author: "Michael Schatz"
date: "10/8/2021"
output: html_document
---
  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)

## Read in initial packages 
library(jsonlite)
library(dplyr)
library(googledrive)
library(purrr)
library(scales)
library(ggplot2)

##Read In Data 

## Default parsing of match results is a little messy so setting simplify vector to FALSE and will parse through myself to get relevant information in a hopefully cleaner format 

match_results = fromJSON("https://drive.google.com/u/0/uc?id=19hVoi9f7n7etcmSXx7WHeiDp9pOLpQvN&export=download", 
                simplifyVector = TRUE)

##Innings results too large to read in directly so will need to download with googledrive package first then read in. When running this will require some interactivity to work the first time as the user will need to authenticate. If productionizing  I would put this into a separate script or find a more robust way to make the data accessible.  

##I have commented out the download line so the file does not get redownloaded each time I knit the document. 

# drive_download(as_id("1wQO9zr1VH8bY2W4Ca6cMxPdAoPOHo6X6"), "innings_results.json", overwrite = TRUE)

##Read in innings results. Data reads in a little cleaner by default so can leave in its simplified state 
inning_results = fromJSON("innings_results.json", simplifyVector = TRUE)

```



## Question 1. 

I would rate my knowledge of cricket as a 2. I knew of the sport and the goal to knock down wickets and score runs by running back and forth. I also knew of the Test and T20 distinctions but did not know the difference between the two, but not much else. I could not name any teams or players. Did not know of any positions outside of the batsment or bowler. I did once accidentally knock a friends tooth out with a cricket bat when I was 10 (but that's a story for another time).

![](https://media.giphy.com/media/BsQAVgY6ksvIY/giphy.gif)



## Question 1. 


```{r q1_checks, echo=FALSE, include=FALSE}

## Checking that there are no instances where there isn't just two records per matchid 
match_results %>% count(matchid) %>% filter(n!=2)

## Check what the possible values for "result" column are and see that NA indicates that there as a winning/losing team. so will now just need to identify DLS method events. 
match_results %>% count(result)

## See that there is an outcome.result column as well. Unsure the difference between outcome.result and result columns, but will assume that ties in that column should be removed as well. 
match_results %>% count(outcome.result)

## Check outcome.method and see that the D/L value seems to indicate the DLS method matches. Any NA value appears to be a result that we want to include 
match_results %>% count(outcome.method)

## Here we see that there are also 2 matches (4 rows) where there is still a NA outcome.winner column even with the filter of ties and no.result. We'll chalk that up to messy dat and remove those from our data set as well. 
 match_results %>% 
  filter(is.na(result) & is.na(outcome.method)) %>% 
   count(outcome.winner)

```

First we filter out any no results, ties and DLS matches by finding NA values for results and outcome.method
```{r q1_base, echo=TRUE}
match_results_use <- match_results %>% 
  filter(is.na(result) & is.na(outcome.method) & is.na(outcome.result) & !is.na(outcome.winner)  &
           lubridate::year(dates) == 2019) 

valid_row_pct = sprintf("%1.1f%%", 100*nrow(match_results_use)/
                          nrow(match_results %>% filter(lubridate::year(dates) == 2019))) 

```

We can check and see that we are left with `r valid_row_pct` of rows in the filtered set for 2019.  

```{r q1, echo=TRUE, warning=FALSE}
match_records = match_results_use %>% 
  mutate(Won = outcome.winner == teams) %>%  # define a win by if the winner column is equal to the team column for a given match
  group_by(teams, gender) %>% 
  summarise(Total_Wins = sum(Won), Win_PCT = scales::percent(mean(Won), .1), Total_Matches = n()) 
          

```

Below we see the results for male and female teams with the highest win percentage. The **female Australian team** and the **male Netherlands** team had the highest win percentages both at 100% in 2019. 

```{r q1_pct, echo=TRUE, include = TRUE}
match_records %>% 
  group_by(gender) %>% 
  filter(rank(desc(Win_PCT)) == 1)  %>% 
  knitr::kable()
        
```

And here are the results for male and female teams with the highest win totals. In total wins both the **Australian male and female** teams led the pack with 10 and 16 wins respectively. The female leaders remained the same, but the male leader in win% vs total wins was different. 

```{r q1_total, echo=TRUE, include = TRUE}
match_records %>% 
  group_by(gender) %>% 
  filter(rank(desc(Total_Wins)) == 1) %>% knitr::kable()
        
```

One of the most important distinctions between these two numbers is the number of matches that each team played is not constant. While the male Netherlands team had a 100% win percentage, they also only played in 1 match in all of 2019. Meanwhile the Australian female team played in 10 matches an won all 10. Likewise the Australian male team won 16 matches, but also played in 23 matches (tied for the most of any team with India). While neither in the lead in total wins or win percentage, we can see in the table below that the male England team played in 19 matches and won 14 of them (73.7 Win%) which is higher than Australia's win% of 69.6%. 

```{r q1_total_matches, echo=TRUE, include = TRUE}
match_records %>% 
  group_by(gender) %>% 
  filter(rank(desc(Total_Matches)) <= 8) %>% arrange(gender, desc(Total_Matches)) %>%   
  knitr::kable()
        
```

Aside from denominators being important, quality of opponent likely is not constant between teams as well. Looking at the male Netherland's one match in the set, we see that they played Zimbabwe. I do not know much about the quality of each country's team, but would think that Zimbabwe is a weaker team than say India or Pakistan (which the male Australian team played 9 and 6 times respectively)  

```{r q1_competition, echo=FALSE, include = FALSE}

match_results_use %>% filter(teams!="Netherlands" & gender == "male") %>% 
  inner_join( match_results_use %>% filter(teams=="Netherlands" & gender == "male") %>% select(matchid), by = "matchid") %>%
  count(teams) 

match_results_use %>% filter(teams!="Australia" & gender == "male") %>% 
  inner_join(match_results_use %>% filter(teams=="Australia" & gender == "male") %>% select(matchid), by = "matchid") %>% 
  count(teams) %>% 
  arrange(desc(n))
        
```

## Question 2. 


###2b. 


```{r q2_base_elo_function, echo=TRUE, include = FALSE}


elo_x_win = function(r1, r2, s = 20, rating_dif = r2 - r1) {
  return( 
    1/(1+10^((rating_dif)/s)
       )
}

elo_rating_update = function(points, r1, r2, s, K){
  
  return(r1 + K * (points - elo_x_win(r1, r2, s)))
}

```

Looking at the two prediction curves below it suggests expected win percentages follow a sigmoid/logistic function and the value of *s* impacts the grows rate or how quickly the expected win rate will change at different rating differences. In this instance the growth is less gradual for the elo than cdf and has a steeper slope around the inflection point. 
```{r q2b, echo=TRUE, include = FALSE}

rating_dif <- data.frame(rating_dif = c(-30:30))

rating_dif$x_wins <- elo_x_win(r1 = NA, r2 = NA, s= 10, rating_dif = c(-30:30))

rating_dif$cdf = 1 - pnorm(rating_dif$rating_dif, 0, 10)

colors <- c("Sepal Width" = "blue", "Petal Length" = "red", "Petal Width" = "orange")

rating_dif %>% ggplot(aes(x = rating_dif)) +
  geom_line(aes( y = x_wins, color = "elo"))  +
  geom_line(aes(y = cdf, color = "cdf")) +
  scale_color_manual(values = c("elo" = "black", "cdf" = "red")) +
  ggtitle("Comparing elo and cdf curves at s = 10") 

```


###2c. 
below we can see a practical application calculating the log odds at s = 10 where r_j varies from 1-199. In the graph we can see that the log odds of expected wins is linearly related. Knowing this, one could specify a logistic regression with the formula being $points ~ team_i + team_j.    
```{r q2c, echo=FALSE, include = TRUE}


ratings <- data.frame(rating_i = 100 , rating_j = c(1:199))

ratings$x_wins <- elo_x_win(r1 = ratings$rating_i, r2 = ratings$rating_j, s= 10) 

ratings %>% mutate(logodds = log(x_wins/(1-x_wins))) %>% 
ggplot(aes(rating_j, logodds)) +
  geom_point() +
  ggtitle("Log odds of expected wins by oppontent rating when rating_i = 100")

```

### 2d

```{r q2_elo_function, echo=TRUE, include = FALSE}


elo_x_win = function(r1, r2, s = 20) {
  1/(1+10^((r2 - r1)/s))
}

elo_rating_update = function(points, r1, r2, s, K){
  elo_x_win
  
 data[i, "pre_match_r"] + K * (data[i,"points"] - x_win)
}


elo_data = function(data, date_column = "dates", R0 = 100, s = 20, K = 20) {
  
  if(nrow(data %>% filter(result == "no result"))>0) {
    warning("data contains no result matches, those will be removed from the data set") 
  }
  
  ## Check if date_column for ordering exists in data frame 
  if(!date_column %in% names(data)) {
    stop(paste("Error: Provided date_column name '", date_column, "does not exist in the column names of provided data,
               please provide a valid column name to order by"))
  }
  
  data <- data %>% ungroup() %>% 
     filter(coalesce(result, "") != "no result") %>% 
  mutate(Won = outcome.winner == teams & coalesce(result, outcome.result, "") != "tie", 
         Loss = outcome.winner != teams & coalesce(result, outcome.result, "") != "tie",
         points = case_when(Won ~ 1, Loss ~ 0, TRUE ~ .5)
         ) %>% 
    arrange(!!sym(date_column))
  ##set initial rating for teams 

 
 #rank games by team in order of date to be able to easily pull the team's ranking prior to a game
 data <- data %>% group_by(teams, gender) %>% 
   mutate(team_game_rank = rank(!!sym(date_column))) %>% 
   ungroup() %>% 
   data.frame() ## set back to data.frame to deal with differences in dplyr vs base r filter/assignment syntax
  
   data$pre_match_r = R0
 data$post_match_r = as.numeric(NA)
data$x_win = as.numeric(NA)
 
  for(i in 1:nrow(data)) {
    
    # set row being used for reference
    row_use = data[i,]
    
    opponent_row = data %>% filter(matchid ==  row_use$matchid & teams !=  row_use$teams)
    
    x_win =  elo_x_win(row_use$pre_match_r, opponent_row$pre_match_r, s = s)
    
    data[i,]$x_win = x_win
    
    data[i, "post_match_r"] = data[i, "pre_match_r"] + K * (data[i,"points"] - x_win)
   
    ## check to see if a row exists/we're at the last game for a team. If not, then update their pregame rating for their next game
    if(!row_use$team_game_rank == max(data[data$teams == row_use$teams & 
                                           data$gender == row_use$gender, "team_game_rank"])) {
    data[data$team_game_rank == row_use$team_game_rank + 1 & 
           data$teams == row_use$teams & data$gender == row_use$gender, "pre_match_r"] = data[i, "post_match_r"] 
    }
  }
  return(data) 
}

  
```

``` {r q2d application, echo=TRUE, include = FALSE}

elo_data_use <- match_results %>% filter(gender == "male" & match_type == "ODI" & coalesce(result, "") != "no result") %>% 
  mutate(Won = outcome.winner == teams & coalesce(result, "") != "tie", 
         Loss = outcome.winner != teams & coalesce(result, "") != "tie"
         )

elo_results = elo_data(elo_data_use)

```